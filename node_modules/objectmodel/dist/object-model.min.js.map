{"version":3,"file":"object-model.min.js","sources":["../src/helpers.js","../src/object-model.js","../src/list-model.js","../src/array-model.js","../src/function-model.js","../src/map-model.js","../src/set-model.js"],"sourcesContent":["export const\n\tObjectProto = Object.prototype,\n\tbettertypeof = x => ObjectProto.toString.call(x).match(/\\s([a-zA-Z]+)/)[1],\n\tgetProto = Object.getPrototypeOf,\n\tsetProto = Object.setPrototypeOf,\n\n\thas = (o, prop) => ObjectProto.hasOwnProperty.call(o, prop),\n\tis = (Constructor, obj) => obj instanceof Constructor,\n\tisFunction = f => typeof f === \"function\",\n\tisObject = o => o && typeof o === \"object\",\n\tisString = s => typeof s === \"string\",\n\tisPlainObject = o => isObject(o) && getProto(o) === ObjectProto,\n\tisIterable = x => x && isFunction(x[Symbol.iterator]),\n\n\tproxify = (val, traps) => new Proxy(val, traps),\n\n\tmerge = (target, src = {}) => {\n\t\tfor (let key in src) {\n\t\t\tif (isPlainObject(src[key])) {\n\t\t\t\tconst o = {}\n\t\t\t\tmerge(o, target[key])\n\t\t\t\tmerge(o, src[key])\n\t\t\t\ttarget[key] = o\n\t\t\t} else {\n\t\t\t\ttarget[key] = src[key]\n\t\t\t}\n\t\t}\n\t\treturn target\n\t},\n\n\tdefine = (obj, key, value, enumerable = false) => {\n\t\tObject.defineProperty(obj, key, { value, enumerable, writable: true, configurable: true })\n\t},\n\n\textend = (child, parent, props) => {\n\t\tchild.prototype = Object.assign(Object.create(parent.prototype, {\n\t\t\tconstructor: {\n\t\t\t\tvalue: child,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t}\n\t\t}), props)\n\t\tsetProto(child, parent)\n\t}","import {\n\tbettertypeof, define, extend, getProto, has,\n\tis, isFunction, isObject, isPlainObject, isString,\n\tmerge, ObjectProto, proxify, setProto\n} from \"./helpers.js\"\n\nexport const\n\t_check = Symbol(),\n\t_checked = Symbol(), // used to skip validation at instanciation for perf\n\t_original = Symbol(), // used to bypass proxy\n\n\tinitModel = (def, constructor, parent, init, getTraps, useNew) => {\n\t\tconst model = function (val = model.default, mode) {\n\t\t\tif (useNew && !is(model, this)) return new model(val)\n\t\t\tif (init) val = init(val, model, this)\n\n\t\t\tif (mode === _checked || check(model, val))\n\t\t\t\treturn getTraps ? proxify(val, getTraps(model)) : val\n\t\t}\n\n\t\tif (parent) extend(model, parent)\n\t\tsetProto(model, constructor.prototype)\n\t\tmodel.constructor = constructor\n\t\tmodel.definition = def\n\t\tmodel.assertions = [...model.assertions]\n\t\tdefine(model, \"errors\", [])\n\t\tdelete model.name\n\t\treturn model\n\t},\n\n\tinitObjectModel = (obj, model, _this) => {\n\t\tif (is(model, obj)) return obj\n\n\t\tif (!isObject(obj) && !isFunction(obj) && obj !== undefined) {\n\t\t\tstackError(model.errors, Object, obj)\n\t\t}\n\n\t\tmerge(_this, model.default)\n\t\tif (model.parentClass) merge(obj, new model.parentClass(obj))\n\t\tmerge(_this, obj)\n\t\treturn _this\n\t},\n\n\textendModel = (child, parent, newProps) => {\n\t\textend(child, parent, newProps)\n\t\tchild.assertions.push(...parent.assertions)\n\t\treturn child\n\t},\n\n\tstackError = (errors, expected, received, path, message) => {\n\t\terrors.push({ expected, received, path, message })\n\t},\n\n\tunstackErrors = (model, collector = model.errorCollector) => {\n\t\tconst nbErrors = model.errors.length\n\t\tif (nbErrors > 0) {\n\t\t\tconst errors = model.errors.map(err => {\n\t\t\t\tif (!err.message) {\n\t\t\t\t\terr.message = \"expecting \" + (err.path ? err.path + \" to be \" : \"\") + formatDefinition(err.expected)\n\t\t\t\t\t\t+ \", got \" + (err.received != null ? bettertypeof(err.received) + \" \" : \"\") + format(err.received)\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t})\n\n\t\t\tmodel.errors.length = 0\n\t\t\tcollector.call(model, errors) // throw all errors collected\n\t\t}\n\t\treturn nbErrors\n\t},\n\n\tisModelInstance = i => i && getProto(i) && is(Model, getProto(i).constructor),\n\n\tparseDefinition = (def) => {\n\t\tif (isPlainObject(def)) {\n\t\t\tdef = {}\n\t\t\tfor (let key in def) { def[key] = parseDefinition(def[key]) }\n\t\t}\n\t\telse if (!Array.isArray(def)) return [def]\n\t\telse if (def.length === 1) return [def[0], undefined, null]\n\n\t\treturn def\n\t},\n\n\tformatDefinition = (def, stack) => {\n\t\tconst parts = parseDefinition(def).map(d => format(d, stack))\n\t\treturn parts.length > 1 ? parts.join(\" or \") : parts[0]\n\t},\n\n\tformatAssertions = fns => fns.length ? `(${fns.map(f => f.name || f.description || f)})` : \"\",\n\n\textendDefinition = (def, newParts = []) => {\n\t\tif (newParts.length > 0) {\n\t\t\tdef = [].concat(def, ...[].concat(newParts))// clone to lose ref\n\t\t\t\t.filter((value, index, self) => self.indexOf(value) === index) // remove duplicates\n\t\t}\n\n\t\treturn def\n\t},\n\n\tcheck = (model, obj) => {\n\t\tmodel[_check](obj, null, model.errors, [], true);\n\t\treturn !unstackErrors(model)\n\t},\n\n\tcheckDefinition = (obj, def, path, errors, stack, shouldCast) => {\n\t\tconst indexFound = stack.indexOf(def)\n\t\tif (indexFound !== -1 && stack.indexOf(def, indexFound + 1) !== -1)\n\t\t\treturn obj // if found twice in call stack, cycle detected, skip validation\n\n\t\tif (Array.isArray(def) && def.length === 1 && obj != null) {\n\t\t\tdef = def[0] // shorten validation path for optionals\n\t\t}\n\n\t\tif (is(Model, def)) {\n\t\t\tif (shouldCast) obj = cast(obj, def)\n\t\t\tdef[_check](obj, path, errors, stack.concat(def))\n\t\t}\n\t\telse if (isPlainObject(def)) {\n\t\t\tfor (let key in def) {\n\t\t\t\tconst val = obj ? obj[key] : undefined\n\t\t\t\tcheckDefinition(val, def[key], formatPath(path, key), errors, stack, shouldCast)\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tconst pdef = parseDefinition(def)\n\t\t\tif (pdef.some(part => checkDefinitionPart(obj, part, path, stack))) {\n\t\t\t\treturn shouldCast ? cast(obj, def) : obj\n\t\t\t}\n\n\t\t\tstackError(errors, def, obj, path)\n\t\t}\n\n\t\treturn obj\n\t},\n\n\tcheckDefinitionPart = (obj, def, path, stack, shouldCast) => {\n\t\tif (def === Any) return true\n\t\tif (obj == null) return obj === def\n\t\tif (isPlainObject(def) || is(Model, def)) { // object or model as part of union type\n\t\t\tconst errors = []\n\t\t\tcheckDefinition(obj, def, path, errors, stack, shouldCast)\n\t\t\treturn !errors.length\n\t\t}\n\t\tif (is(RegExp, def)) return def.test(obj)\n\t\tif (def === Number || def === Date) return obj.constructor === def && !isNaN(obj)\n\t\treturn obj === def\n\t\t\t|| (isFunction(def) && is(def, obj))\n\t\t\t|| obj.constructor === def\n\t},\n\n\tcheckAssertions = (obj, model, path, errors = model.errors) => {\n\t\tfor (let assertion of model.assertions) {\n\t\t\tlet result\n\t\t\ttry {\n\t\t\t\tresult = assertion.call(model, obj)\n\t\t\t} catch (err) {\n\t\t\t\tresult = err\n\t\t\t}\n\t\t\tif (result !== true) {\n\t\t\t\tconst onFail = isFunction(assertion.description) ? assertion.description : (assertionResult, value) =>\n\t\t\t\t\t`assertion \"${assertion.description}\" returned ${format(assertionResult)} `\n\t\t\t\t\t+ `for ${path ? path + \" =\" : \"value\"} ${format(value)}`\n\t\t\t\tstackError(errors, assertion, obj, path, onFail.call(model, result, obj, path))\n\t\t\t}\n\t\t}\n\t},\n\n\tformat = (obj, stack = []) => {\n\t\tif (stack.length > 15 || stack.includes(obj)) return \"...\"\n\t\tif (obj === null || obj === undefined) return String(obj)\n\t\tif (isString(obj)) return `\"${obj}\"`\n\t\tif (is(Model, obj)) return obj.toString(stack)\n\n\t\tstack.unshift(obj)\n\n\t\tif (isFunction(obj)) return obj.name || obj.toString()\n\t\tif (is(Map, obj) || is(Set, obj)) return format([...obj])\n\t\tif (Array.isArray(obj)) return `[${obj.map(item => format(item, stack)).join(\", \")}]`\n\t\tif (obj.toString && obj.toString !== ObjectProto.toString) return obj.toString()\n\t\tif (isObject(obj)) {\n\t\t\tconst props = Object.keys(obj),\n\t\t\t\tindent = \"\\t\".repeat(stack.length)\n\t\t\treturn `{${props.map(\n\t\t\t\tkey => `\\n${indent + key}: ${format(obj[key], [...stack])}`\n\t\t\t).join(\", \")} ${props.length ? `\\n${indent.slice(1)}` : \"\"}}`\n\t\t}\n\n\t\treturn String(obj)\n\t},\n\n\tformatPath = (path, key) => path ? path + \".\" + key : key,\n\n\tcontrolMutation = (model, def, path, o, key, privateAccess, applyMutation) => {\n\t\tconst newPath = formatPath(path, key),\n\t\t\tisPrivate = model.conventionForPrivate(key),\n\t\t\tisConstant = model.conventionForConstant(key),\n\t\t\tisOwnProperty = has(o, key),\n\t\t\tinitialPropDescriptor = isOwnProperty && Object.getOwnPropertyDescriptor(o, key)\n\n\t\tif (key in def && ((isPrivate && !privateAccess) || (isConstant && o[key] !== undefined)))\n\t\t\tcannot(`modify ${isPrivate ? \"private\" : \"constant\"} property ${key}`, model)\n\n\t\tapplyMutation()\n\t\tif (has(def, key)) checkDefinition(o[key], def[key], newPath, model.errors, [])\n\t\tcheckAssertions(o, model, newPath)\n\n\t\tconst nbErrors = model.errors.length\n\t\tif (nbErrors) {\n\t\t\tif (isOwnProperty) Object.defineProperty(o, key, initialPropDescriptor)\n\t\t\telse delete o[key] // back to the initial property defined in prototype chain\n\n\t\t\tunstackErrors(model)\n\t\t}\n\n\t\treturn !nbErrors\n\t},\n\n\tcannot = (msg, model) => {\n\t\tmodel.errors.push({ message: \"cannot \" + msg })\n\t},\n\n\tcast = (obj, defNode = []) => {\n\t\tif (!obj || isPlainObject(defNode) || is(BasicModel, defNode) || isModelInstance(obj))\n\t\t\treturn obj // no value or not leaf or already a model instance\n\n\t\tconst def = parseDefinition(defNode),\n\t\t\tsuitableModels = []\n\n\t\tfor (let part of def) {\n\t\t\tif (is(Model, part) && !is(BasicModel, part) && part.test(obj))\n\t\t\t\tsuitableModels.push(part)\n\t\t}\n\n\t\tif (suitableModels.length === 1) {\n\t\t\t// automatically cast to suitable model when explicit (autocasting)\n\t\t\treturn new suitableModels[0](obj, _checked)\n\t\t}\n\n\t\tif (suitableModels.length > 1)\n\t\t\tconsole.warn(`Ambiguous model for value ${format(obj)}, could be ${suitableModels.join(\" or \")}`)\n\n\t\treturn obj\n\t},\n\n\n\tgetProp = (val, model, def, path, privateAccess) => {\n\t\tif (!isPlainObject(def)) return cast(val, def)\n\t\treturn proxify(val, getTraps(model, def, path, privateAccess))\n\t},\n\n\tgetTraps = (model, def, path, privateAccess) => {\n\t\tconst grantPrivateAccess = f => proxify(f, {\n\t\t\tapply(fn, ctx, args) {\n\t\t\t\tprivateAccess = true\n\t\t\t\tconst result = Reflect.apply(fn, ctx, args)\n\t\t\t\tprivateAccess = false\n\t\t\t\treturn result\n\t\t\t}\n\t\t})\n\n\t\treturn {\n\t\t\tget(o, key) {\n\t\t\t\tif (key === _original) return o\n\n\t\t\t\tif (!isString(key)) return Reflect.get(o, key)\n\n\t\t\t\tconst newPath = formatPath(path, key)\n\t\t\t\tconst inDef = has(def, key)\n\t\t\t\tconst defPart = def[key]\n\n\t\t\t\tif (!privateAccess && inDef && model.conventionForPrivate(key)) {\n\t\t\t\t\tcannot(`access to private property ${newPath}`, model)\n\t\t\t\t\tunstackErrors(model)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tlet value = o[key]\n\n\t\t\t\tif (inDef && value && has(o, key) && !isPlainObject(defPart) && !isModelInstance(value)) {\n\t\t\t\t\tReflect.set(o, key, value = cast(value, defPart)) // cast nested models\n\t\t\t\t}\n\n\t\t\t\tif (isFunction(value) && key !== \"constructor\" && !privateAccess) {\n\t\t\t\t\treturn grantPrivateAccess(value)\n\t\t\t\t}\n\n\t\t\t\tif (isPlainObject(defPart) && !value) {\n\t\t\t\t\to[key] = value = {} // null-safe traversal\n\t\t\t\t}\n\n\t\t\t\treturn getProp(value, model, defPart, newPath, privateAccess)\n\t\t\t},\n\n\t\t\tset(o, key, val) {\n\t\t\t\treturn controlMutation(model, def, path, o, key, privateAccess, () => Reflect.set(o, key, cast(val, def[key])))\n\t\t\t},\n\n\t\t\tdeleteProperty(o, key) {\n\t\t\t\treturn controlMutation(model, def, path, o, key, privateAccess, () => Reflect.deleteProperty(o, key))\n\t\t\t},\n\n\t\t\tdefineProperty(o, key, args) {\n\t\t\t\treturn controlMutation(model, def, path, o, key, privateAccess, () => Reflect.defineProperty(o, key, args))\n\t\t\t},\n\n\t\t\thas(o, key) {\n\t\t\t\treturn Reflect.has(o, key) && Reflect.has(def, key) && !model.conventionForPrivate(key)\n\t\t\t},\n\n\t\t\townKeys(o) {\n\t\t\t\treturn Reflect.ownKeys(o).filter(key => Reflect.has(def, key) && !model.conventionForPrivate(key))\n\t\t\t},\n\n\t\t\tgetOwnPropertyDescriptor(o, key) {\n\t\t\t\tlet descriptor\n\t\t\t\tif (!model.conventionForPrivate(key)) {\n\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(def, key)\n\t\t\t\t\tif (descriptor !== undefined) descriptor.value = o[key]\n\t\t\t\t}\n\n\t\t\t\treturn descriptor\n\t\t\t}\n\t\t}\n\t}\n\n\nexport function Model(def, params) {\n\treturn isPlainObject(def) ? new ObjectModel(def, params) : new BasicModel(def)\n}\n\nObject.assign(Model.prototype, {\n\tname: \"Model\",\n\tassertions: [],\n\n\tconventionForConstant: key => key.toUpperCase() === key,\n\tconventionForPrivate: key => key[0] === \"_\",\n\n\ttoString(stack) {\n\t\treturn has(this, \"name\") ? this.name : formatDefinition(this.definition, stack) + formatAssertions(this.assertions)\n\t},\n\n\tas(name) {\n\t\tdefine(this, \"name\", name)\n\t\treturn this\n\t},\n\n\tdefaultTo(val) {\n\t\tthis.default = val\n\t\treturn this\n\t},\n\n\t[_check](obj, path, errors, stack) {\n\t\tcheckDefinition(obj, this.definition, path, errors, stack)\n\t\tcheckAssertions(obj, this, path, errors)\n\t},\n\n\ttest(obj, errorCollector) {\n\t\tlet model = this\n\t\twhile (!has(model, \"errorCollector\")) {\n\t\t\tmodel = getProto(model)\n\t\t}\n\n\t\tconst initialErrorCollector = model.errorCollector\n\t\tlet failed\n\n\t\tmodel.errorCollector = errors => {\n\t\t\tfailed = true\n\t\t\tif (errorCollector) errorCollector.call(this, errors)\n\t\t}\n\n\t\tnew this(obj) // may trigger errorCollector\n\n\t\tmodel.errorCollector = initialErrorCollector\n\t\treturn !failed\n\t},\n\n\terrorCollector(errors) {\n\t\tconst e = new TypeError(errors.map(e => e.message).join(\"\\n\"))\n\t\te.stack = e.stack.replace(/\\n.*object-model(.|\\n)*object-model.*/, \"\") // blackbox objectmodel in stacktrace\n\t\tthrow e\n\t},\n\n\tassert(assertion, description = format(assertion)) {\n\t\tdefine(assertion, \"description\", description)\n\t\tthis.assertions = this.assertions.concat(assertion)\n\t\treturn this\n\t}\n})\n\n\nexport function BasicModel(def) {\n\treturn initModel(def, BasicModel)\n}\n\nextend(BasicModel, Model, {\n\textend(...newParts) {\n\t\tconst child = extendModel(new BasicModel(extendDefinition(this.definition, newParts)), this)\n\t\tfor (let part of newParts) {\n\t\t\tif (is(BasicModel, part)) child.assertions.push(...part.assertions)\n\t\t}\n\n\t\treturn child\n\t}\n})\n\nexport function ObjectModel(def) {\n\treturn initModel(def, ObjectModel, Object, initObjectModel, model => getTraps(model, def), true)\n}\n\nextend(ObjectModel, Model, {\n\tdefaultTo(obj) {\n\t\tconst def = this.definition\n\t\tfor (let key in obj) {\n\t\t\tif (has(def, key)) {\n\t\t\t\tobj[key] = checkDefinition(obj[key], def[key], key, this.errors, [], true)\n\t\t\t}\n\t\t}\n\t\tunstackErrors(this)\n\t\tthis.default = obj;\n\t\treturn this\n\t},\n\n\ttoString(stack) {\n\t\treturn format(this.definition, stack)\n\t},\n\n\textend(...newParts) {\n\t\tconst definition = { ...this.definition }\n\t\tconst proto = { ...this.prototype }\n\t\tconst defaults = { ...this.default }\n\t\tconst newAssertions = []\n\n\t\tfor (let part of newParts) {\n\t\t\tif (is(Model, part)) {\n\t\t\t\tmerge(definition, part.definition)\n\t\t\t\tmerge(defaults, part.default)\n\t\t\t\tnewAssertions.push(...part.assertions)\n\t\t\t}\n\t\t\tif (isFunction(part)) merge(proto, part.prototype)\n\t\t\tif (isObject(part)) merge(definition, part)\n\t\t}\n\n\t\tconst submodel = extendModel(new ObjectModel(definition), this, proto).defaultTo(defaults)\n\t\tsubmodel.assertions = [...this.assertions, ...newAssertions]\n\n\t\tif (getProto(this) !== ObjectModel.prototype) { // extended class\n\t\t\tsubmodel.parentClass = this\n\t\t}\n\n\t\treturn submodel\n\t},\n\n\t[_check](obj, path, errors, stack, shouldCast) {\n\t\tif (isObject(obj)) {\n\t\t\tcheckDefinition(obj[_original] || obj, this.definition, path, errors, stack, shouldCast)\n\t\t}\n\t\telse stackError(errors, this, obj, path)\n\n\t\tcheckAssertions(obj, this, path, errors)\n\t}\n})\n\nexport const Any = proxify(BasicModel(), {\n\tapply(target, ctx, [def]) {\n\t\tconst anyOf = Object.create(Any)\n\t\tanyOf.definition = def;\n\t\treturn anyOf\n\t}\n})\nAny.definition = Any\nAny.toString = () => \"Any\"\n\nAny.remaining = function (def) { this.definition = def }\nextend(Any.remaining, Any, {\n\ttoString() { return \"...\" + formatDefinition(this.definition) }\n})\nAny[Symbol.iterator] = function* () { yield new Any.remaining(this.definition) }","\nimport { _original, checkAssertions, checkDefinition, initModel, unstackErrors } from \"./object-model.js\"\nimport { has, isFunction, proxify } from \"./helpers.js\"\n\nexport const initListModel = (base, constructor, def, init, clone, mutators, otherTraps) => {\n\n\treturn initModel(def, constructor, base, init, model => Object.assign({\n\t\tgetPrototypeOf: () => model.prototype,\n\t\tget(l, key) {\n\t\t\tif (key === _original) return l\n\n\t\t\tconst val = l[key]\n\t\t\treturn isFunction(val) ? proxify(val, {\n\t\t\t\tapply(fn, ctx, args) {\n\t\t\t\t\tif (has(mutators, key)) {\n\t\t\t\t\t\t// indexes of arguments to check def + cast\n\t\t\t\t\t\tconst [begin, end = args.length - 1, getArgDef] = mutators[key]\n\t\t\t\t\t\tfor (let i = begin; i <= end; i++) {\n\t\t\t\t\t\t\tconst argDef = getArgDef ? getArgDef(i) : model.definition\n\t\t\t\t\t\t\targs[i] = checkDefinition(\n\t\t\t\t\t\t\t\targs[i],\n\t\t\t\t\t\t\t\targDef,\n\t\t\t\t\t\t\t\t`${base.name}.${key} arguments[${i}]`,\n\t\t\t\t\t\t\t\tmodel.errors,\n\t\t\t\t\t\t\t\t[],\n\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (model.assertions.length > 0) {\n\t\t\t\t\t\t\tconst testingClone = clone(l)\n\t\t\t\t\t\t\tfn.apply(testingClone, args)\n\t\t\t\t\t\t\tcheckAssertions(testingClone, model, `after ${key} mutation`)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tunstackErrors(model)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn fn.apply(l, args)\n\t\t\t\t}\n\t\t\t}) : val\n\t\t}\n\t}, otherTraps))\n}","import {\n\t_original, _check, cast, checkAssertions, checkDefinition,\n\textendDefinition, extendModel, formatDefinition, Model, stackError, unstackErrors\n} from \"./object-model.js\"\nimport { initListModel } from \"./list-model.js\"\nimport { extend } from \"./helpers.js\"\n\nexport default function ArrayModel(initialDefinition) {\n\tconst model = initListModel(\n\t\tArray,\n\t\tArrayModel,\n\t\tinitialDefinition,\n\t\ta => Array.isArray(a) ? a.map(arg => cast(arg, model.definition)) : a,\n\t\ta => [...a],\n\t\t{\n\t\t\t\"copyWithin\": [],\n\t\t\t\"fill\": [0, 0],\n\t\t\t\"pop\": [],\n\t\t\t\"push\": [0],\n\t\t\t\"reverse\": [],\n\t\t\t\"shift\": [],\n\t\t\t\"sort\": [],\n\t\t\t\"splice\": [2],\n\t\t\t\"unshift\": [0]\n\t\t},\n\t\t{\n\t\t\tset(arr, key, val) {\n\t\t\t\treturn controlMutation(model, arr, key, val, (a, v) => a[key] = v, true)\n\t\t\t},\n\n\t\t\tdeleteProperty(arr, key) {\n\t\t\t\treturn controlMutation(model, arr, key, undefined, a => delete a[key])\n\t\t\t}\n\t\t}\n\t)\n\n\treturn model\n}\n\nextend(ArrayModel, Model, {\n\ttoString(stack) {\n\t\treturn \"Array of \" + formatDefinition(this.definition, stack)\n\t},\n\n\t[_check](arr, path, errors, stack) {\n\t\tif (Array.isArray(arr))\n\t\t\t(arr[_original] || arr).forEach((a, i) => checkDefinition(a, this.definition, `${path || \"Array\"}[${i}]`, errors, stack))\n\t\telse stackError(errors, this, arr, path)\n\n\t\tcheckAssertions(arr, this, path, errors)\n\t},\n\n\textend(...newParts) {\n\t\treturn extendModel(new ArrayModel(extendDefinition(this.definition, newParts)), this)\n\t}\n})\n\nconst controlMutation = (model, array, key, value, applyMutation, canBeExtended) => {\n\tconst path = `Array[${key}]`\n\tconst isInDef = (+key >= 0 && (canBeExtended || key in array))\n\tif (isInDef) value = checkDefinition(value, model.definition, path, model.errors, [], true)\n\n\tconst testArray = [...array]\n\tapplyMutation(testArray)\n\tcheckAssertions(testArray, model, path)\n\tconst isSuccess = !unstackErrors(model)\n\tif (isSuccess) applyMutation(array, value)\n\treturn isSuccess\n}","import {\n\t_check, _original, Any, checkAssertions, checkDefinition, extendDefinition, extendModel,\n\tformatDefinition, initModel, Model, stackError, unstackErrors\n} from \"./object-model.js\"\nimport { extend, is, isFunction } from \"./helpers.js\"\n\nexport default function FunctionModel(...argsDef) {\n\treturn initModel({ arguments: argsDef }, FunctionModel, Function, null, model => ({\n\t\tgetPrototypeOf: () => model.prototype,\n\n\t\tget(fn, key) {\n\t\t\treturn key === _original ? fn : fn[key]\n\t\t},\n\n\t\tapply(fn, ctx, args) {\n\t\t\tconst def = model.definition\n\t\t\tconst remainingArgDef = def.arguments.find(argDef => is(Any.remaining, argDef))\n\t\t\tconst nbArgsToCheck = remainingArgDef ? Math.max(args.length, def.arguments.length - 1) : def.arguments.length\n\n\t\t\tfor (let i = 0; i < nbArgsToCheck; i++) {\n\t\t\t\tconst argDef = remainingArgDef && i >= def.arguments.length - 1 ? remainingArgDef.definition : def.arguments[i]\n\t\t\t\targs[i] = checkDefinition(args[i], argDef, `arguments[${i}]`, model.errors, [], true)\n\t\t\t}\n\n\t\t\tcheckAssertions(args, model, \"arguments\")\n\n\t\t\tlet result\n\t\t\tif (!model.errors.length) {\n\t\t\t\tresult = Reflect.apply(fn, ctx, args)\n\t\t\t\tif (\"return\" in def)\n\t\t\t\t\tresult = checkDefinition(result, def.return, \"return value\", model.errors, [], true)\n\t\t\t}\n\t\t\tunstackErrors(model)\n\t\t\treturn result\n\t\t}\n\t}))\n}\n\nextend(FunctionModel, Model, {\n\ttoString(stack = []) {\n\t\tlet out = `Function(${this.definition.arguments.map(\n\t\t\targDef => formatDefinition(argDef, [...stack])\n\t\t).join(\", \")})`\n\n\t\tif (\"return\" in this.definition) {\n\t\t\tout += \" => \" + formatDefinition(this.definition.return, stack)\n\t\t}\n\t\treturn out\n\t},\n\n\treturn(def) {\n\t\tthis.definition.return = def\n\t\treturn this\n\t},\n\n\textend(newArgs, newReturns) {\n\t\tconst args = this.definition.arguments,\n\t\t\t  mixedArgs = newArgs.map((a, i) => extendDefinition(i in args ? args[i] : [], newArgs[i])),\n\t\t\t  mixedReturns = extendDefinition(this.definition.return, newReturns)\n\t\treturn extendModel(new FunctionModel(...mixedArgs).return(mixedReturns), this)\n\t},\n\n\t[_check](f, path, errors) {\n\t\tif (!isFunction(f)) stackError(errors, \"Function\", f, path)\n\t}\n})","import {\n\t_check, cast, checkAssertions, checkDefinition,\n\textendDefinition, extendModel, format, formatDefinition, Model, stackError\n} from \"./object-model.js\"\nimport { initListModel } from \"./list-model.js\"\nimport { extend, is, isIterable } from \"./helpers.js\"\n\nexport default function MapModel(initialKeyDefinition, initialValueDefinition) {\n\tconst getDef = i => i === 0 ? model.definition.key : model.definition.value;\n\tconst model = initListModel(\n\t\tMap,\n\t\tMapModel,\n\t\t{ key: initialKeyDefinition, value: initialValueDefinition },\n\t\tit => isIterable(it) ? new Map([...it].map(pair => pair.map((x, i) => cast(x, getDef(i))))) : it,\n\t\tmap => new Map(map),\n\t\t{\n\t\t\t\"set\": [0, 1, getDef],\n\t\t\t\"delete\": [],\n\t\t\t\"clear\": []\n\t\t}\n\t)\n\n\treturn model\n}\n\nextend(MapModel, Model, {\n\ttoString(stack) {\n\t\treturn `Map of ${formatDefinition(this.definition.key, stack)} : ${formatDefinition(this.definition.value, stack)}`\n\t},\n\n\t[_check](map, path, errors, stack) {\n\t\tif (is(Map, map)) {\n\t\t\tpath = path || \"Map\"\n\t\t\tfor (let [key, value] of map) {\n\t\t\t\tcheckDefinition(key, this.definition.key, `${path} key`, errors, stack)\n\t\t\t\tcheckDefinition(value, this.definition.value, `${path}[${format(key)}]`, errors, stack)\n\t\t\t}\n\t\t} else stackError(errors, this, map, path)\n\n\t\tcheckAssertions(map, this, path, errors)\n\t},\n\n\textend(keyParts, valueParts) {\n\t\treturn extendModel(new MapModel(\n\t\t\textendDefinition(this.definition.key, keyParts),\n\t\t\textendDefinition(this.definition.value, valueParts)\n\t\t), this)\n\t}\n})","import {\n\t_check, cast, checkAssertions, checkDefinition,\n\textendDefinition, extendModel, formatDefinition, Model, stackError\n} from \"./object-model.js\"\nimport { initListModel } from \"./list-model.js\"\nimport { extend, is, isIterable } from \"./helpers.js\"\n\nexport default function SetModel(initialDefinition) {\n\tconst model = initListModel(\n\t\tSet,\n\t\tSetModel,\n\t\tinitialDefinition,\n\t\tit => isIterable(it) ? new Set([...it].map(val => cast(val, model.definition))) : it,\n\t\tset => new Set(set),\n\t\t{\n\t\t\t\"add\": [0, 0],\n\t\t\t\"delete\": [],\n\t\t\t\"clear\": []\n\t\t}\n\t)\n\n\treturn model\n}\n\nextend(SetModel, Model, {\n\ttoString(stack) {\n\t\treturn \"Set of \" + formatDefinition(this.definition, stack)\n\t},\n\n\t[_check](set, path, errors, stack) {\n\t\tif (is(Set, set)) {\n\t\t\tfor (let item of set.values()) {\n\t\t\t\tcheckDefinition(item, this.definition, `${path || \"Set\"} value`, errors, stack)\n\t\t\t}\n\t\t} else stackError(errors, this, set, path)\n\t\tcheckAssertions(set, this, path, errors)\n\t},\n\n\textend(...newParts) {\n\t\treturn extendModel(new SetModel(extendDefinition(this.definition, newParts)), this)\n\t}\n})"],"names":["ObjectProto","Object","prototype","getProto","getPrototypeOf","setProto","setPrototypeOf","has","o","prop","hasOwnProperty","call","is","Constructor","obj","isFunction","f","isObject","isString","s","isPlainObject","isIterable","x","Symbol","iterator","proxify","val","traps","Proxy","merge","target","src","key","define","value","enumerable","defineProperty","writable","configurable","extend","child","parent","props","assign","create","constructor","_check","_checked","_original","initModel","def","init","getTraps","useNew","model","default","mode","this","check","definition","assertions","name","initObjectModel","_this","undefined","stackError","errors","parentClass","extendModel","newProps","push","expected","received","path","message","unstackErrors","collector","errorCollector","nbErrors","length","map","err","formatDefinition","toString","match","format","isModelInstance","i","Model","parseDefinition","Array","isArray","stack","parts","d","join","extendDefinition","newParts","concat","filter","index","self","indexOf","checkDefinition","shouldCast","indexFound","cast","formatPath","some","part","checkDefinitionPart","Any","RegExp","test","Number","Date","isNaN","checkAssertions","assertion","result","onFail","description","assertionResult","includes","String","unshift","Map","Set","item","keys","indent","repeat","slice","controlMutation","privateAccess","applyMutation","newPath","isPrivate","conventionForPrivate","isConstant","conventionForConstant","isOwnProperty","initialPropDescriptor","getOwnPropertyDescriptor","cannot","msg","defNode","BasicModel","suitableModels","console","warn","[object Object]","Reflect","get","inDef","defPart","set","fn","ctx","args","apply","getProp","deleteProperty","ownKeys","descriptor","params","ObjectModel","toUpperCase","fns","initialErrorCollector","failed","e","TypeError","replace","proto","defaults","newAssertions","submodel","defaultTo","anyOf","remaining","initListModel","base","clone","mutators","otherTraps","l","begin","end","getArgDef","argDef","testingClone","ArrayModel","initialDefinition","a","arg","copyWithin","fill","pop","reverse","shift","sort","splice","arr","v","forEach","array","canBeExtended","testArray","isSuccess","FunctionModel","argsDef","arguments","Function","remainingArgDef","find","nbArgsToCheck","Math","max","return","MapModel","initialKeyDefinition","initialValueDefinition","getDef","it","pair","delete","clear","SetModel","add","out","newArgs","newReturns","mixedArgs","mixedReturns","keyParts","valueParts","values"],"mappings":"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"}